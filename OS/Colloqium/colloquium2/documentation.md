# Документация для коллоквиума 2

## Обзор
Этот каталог содержит реализацию шаблона Singleton с использованием ортогональных стратегий, как описано в книге "Modern C++ Design" Андрея Александреску ([Modern C++ Design](https://www.amazon.nl/-/en/Alexandrescu-Andrei/dp/0201704315)). Реализация демонстрирует разделение аспектов создания, хранения и синхронизации экземпляра.

## Реализация Singleton
Шаблон Singleton обеспечивает создание единственного экземпляра класса с глобальной точкой доступа. Реализация использует шаблонный подход с политиками для достижения гибкости и повторного использования кода.

### Политики
| Политика | Описание |
|----------|----------|
| **CreateUsingNew** | Создает экземпляр с помощью `new` и уничтожает с помощью `delete`. |
| **StaticStorage** | Хранит указатель на экземпляр в статической переменной. |
| **SingleThreadedModel** | Не использует синхронизацию, подходит для однопоточных приложений. |
| **MultiThreadedModel** | Использует `std::mutex` для потокобезопасной инициализации с двойной проверкой блокировки. |

### Особенности
- **Потокобезопасность**: Реализация использует двойную проверку блокировки (double-checked locking) для обеспечения безопасной инициализации в многопоточной среде.
- **Ортогональность**: Политики независимы, что позволяет заменять их без изменения основного кода Singleton.
- **Гибкость**: Возможность настройки создания, хранения и синхронизации через политики.
- **Пример использования**: Класс `Example` демонстрирует создание и повторное использование единственного экземпляра.

## Компиляция и запуск
1. Скомпилировать:
   ```bash
   g++ -std=c++11 singleton.cpp -o singleton -pthread
   ```
2. Запустить:
   ```bash
   ./singleton
   ```

## Вывод программы
При запуске программа создает единственный экземпляр класса `Example` и вызывает его метод `use()` дважды. Ожидаемый вывод:
```
Example created
Example used
Example used
```

## Примечания
- Реализация оптимизирована для многопоточной среды, но может быть переключена на однопоточную модель для упрощения.
- Код следует принципам современного C++ и использует RAII для управления блокировками.
